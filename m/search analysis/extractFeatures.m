
%this function extracts specified features from the data set generated by
%mergePopulations.m It is assumed that the data set is contained in a
%variable labeled "decisions" and is an (m,n) matrix where m is the number
%of observations and n is the number of decision variables
%
%features
%   numSatellites
%   instruments
%   orbits


path = '/Users/nozomihitomi/Dropbox/EOSS/problems/climateCentric/result/ASC Paper/analysis/pop_final/';
load(strcat(path,'baseline.mat'));

%data size
ndata = size(decisions,1);

%5 satellites
maxNumSats = 5;
%12 instruments
maxNumInst = 12;
instName = {'ACE_ORCA','ACE_POL','ACE_LID','CLAR_ERB','ACE_CPR','DESD_SAR','DESD_LID','GACM_VIS','GACM_SWIR','HYSP_TIR','POSTEPS_IRS','CNES_KaRIN'};
%12 orbits
maxNumOrb = 12;
orbName = {'400-polar','400-sso-am','400-sso-pm','400-sso-dd','600-polar','600-sso-am','600-sso-pm','600-sso-dd','800-polar','800-sso-am','800-sso-pm','800-sso-dd'};

%logical indices of instrument assignment
ind_inst = zeros(maxNumSats,maxNumSats * maxNumInst + maxNumSats);
for i=1:maxNumSats
    ind_inst(i,(i-1)*(maxNumInst + 1) + 1:i*(maxNumInst + 1) - 1) = true;
end
ind_inst = logical(ind_inst);

%logical indices of the orbit assignment
ind_orb = zeros(maxNumSats,maxNumSats * maxNumInst + maxNumSats);
for i=1:maxNumSats
    ind_orb(i,i*(maxNumInst +1)) = true;
end
ind_orb = logical(ind_orb);

%number of copies of each intrument in each architecture
copyInstPerArch = zeros(ndata,maxNumInst);
for i=1:maxNumSats
    copyInstPerArch = copyInstPerArch + decisions(:,ind_inst(i,:));
end

%number of instruments per satellite
numInstPerSat = zeros(ndata,maxNumSats);
for i=1:maxNumSats
    sat_i = decisions(:,ind_inst(i,:));
    numInstPerSat(:,i) = sum(sat_i,2);
end

%number of instruments per architecture
numInstPerArch = sum(numInstPerSat,2);

%boolean for if satellite carries any instruments
bool_sat = numInstPerSat > 0;

%numSatellites
numSatellites = sum(bool_sat,2);

%orbits (modify orbit selection id to mean 0 = no satellit occupying that
%orbit)
orbit = zeros(ndata,maxNumSats);
for i=1:maxNumSats
    modifiedOrbitNumber = decisions(:,ind_orb(i,:)) + 1;
    modifiedOrbitNumber(~bool_sat(:,i)) = 0;
    orbit(:,i) = modifiedOrbitNumber;
end

%copies of orbits
orbit_copy = zeros(ndata,maxNumOrb);
for i=1:maxNumOrb
    orbit_copy(:,i) = sum(orbit == i,2);
end

%copies of orbits at specific altitudes:
alt_400 = sum(orbit_copy(:,1:4),2);
alt_600 = sum(orbit_copy(:,5:8),2);
alt_800 = sum(orbit_copy(:,9:12),2);

%copies of orbits at specific RAAN:
raan_polar = sum(orbit_copy(:,1:4:maxNumOrb),2);
raan_sso_am = sum(orbit_copy(:,2:4:maxNumOrb),2);
raan_sso_pm = sum(orbit_copy(:,3:4:maxNumOrb),2);
raan_sso_dd = sum(orbit_copy(:,4:4:maxNumOrb),2);

%plot the number of instruments and satellites in the architecture
figure(1)
scatter(-objectives(:,1),objectives(:,2),5,numSatellites)    
colormap jet
colorbar
title('Number of sats in arch')
figure(2)
scatter(-objectives(:,1),objectives(:,2),5,numInstPerArch)    
colormap jet
colorbar
title('Number of inst per arch')
figure(3)
scatter(-objectives(:,1),objectives(:,2),5,mean(numInstPerSat,2))    
colormap jet
colorbar
title('Avg. Num. of inst per sat')

%plot the number of instrument copies in the architecture
figure(4)
for i=1:maxNumInst
    subplot(3,4,i)
    scatter(-objectives(:,1),objectives(:,2),5,copyInstPerArch(:,i))
    title(instName{i})
    colormap jet
    colorbar
end
figure(5)
bar(sum(copyInstPerArch,1));
h = gca;
h.XTickLabel = instName;
h.XTickLabelRotation = 90;


%plot the number of orbit copies in the architecture
figure(6)
for i=1:maxNumOrb
    subplot(3,4,i)
    scatter(-objectives(:,1),objectives(:,2),5,orbit_copy(:,i))
    title(orbName{i})
    colormap jet
    colorbar
end
figure(7)
bar(sum(orbit_copy,1));
h = gca;
h.XTickLabel = orbName;
h.XTickLabelRotation = 90;

